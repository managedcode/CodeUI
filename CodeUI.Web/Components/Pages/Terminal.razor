@page "/terminal"
@using System.Reactive.Linq
@using System.Text.Json
@using CodeUI.Core.Services
@using CodeUI.Core.Models
@implements IAsyncDisposable
@inject IJSRuntime JSRuntime
@inject ICliExecutor CliExecutor

<PageTitle>Terminal</PageTitle>

<div class="terminal-container">
    <div class="terminal-header">
        <h3>CodeUI Terminal</h3>
        <div class="terminal-controls">
            <button class="btn btn-outline-secondary btn-sm" @onclick="ClearTerminal" disabled="@_isDisposed">
                <i class="bi bi-trash"></i> Clear
            </button>
            <button class="btn btn-outline-success btn-sm" @onclick="FocusTerminal" disabled="@_isDisposed">
                <i class="bi bi-cursor"></i> Focus
            </button>
        </div>
    </div>
    
    <div class="terminal-wrapper">
        <div id="@_terminalId" class="terminal-element"></div>
    </div>
    
    <div class="terminal-status">
        <small class="text-muted">
            @if (CliExecutor.CurrentProcess != null)
            {
                <span class="badge bg-success">Running: @CliExecutor.CurrentProcess.Command @CliExecutor.CurrentProcess.Arguments</span>
            }
            else
            {
                <span class="badge bg-secondary">Ready</span>
            }
        </small>
    </div>
</div>

<style>
    .terminal-container {
        height: calc(100vh - 100px);
        display: flex;
        flex-direction: column;
        border: 1px solid #dee2e6;
        border-radius: 0.375rem;
        overflow: hidden;
        background-color: #1e1e1e;
    }
    
    .terminal-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 0.75rem 1rem;
        background-color: #2d2d30;
        border-bottom: 1px solid #3e3e42;
        color: #ffffff;
    }
    
    .terminal-header h3 {
        margin: 0;
        font-size: 1.1rem;
        font-weight: 500;
    }
    
    .terminal-controls {
        display: flex;
        gap: 0.5rem;
    }
    
    .terminal-wrapper {
        flex: 1;
        padding: 0.5rem;
        overflow: hidden;
        background-color: #1e1e1e;
    }
    
    .terminal-element {
        width: 100%;
        height: 100%;
    }
    
    .terminal-status {
        padding: 0.5rem 1rem;
        background-color: #2d2d30;
        border-top: 1px solid #3e3e42;
        color: #ffffff;
    }
</style>

@code {
    private readonly string _terminalId = $"terminal-{Guid.NewGuid():N}";
    private DotNetObjectReference<Terminal>? _dotNetRef;
    private IDisposable? _outputSubscription;
    private bool _isInitialized = false;
    private bool _isDisposed = false;
    private string _currentInput = string.Empty;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && !_isDisposed)
        {
            // Small delay to ensure DOM and JavaScript are ready
            await Task.Delay(500);
            
            // Try multiple times if initialization fails
            int attempts = 0;
            while (attempts < 3 && !_isInitialized)
            {
                await InitializeTerminalAsync();
                if (!_isInitialized)
                {
                    await Task.Delay(1000);
                    attempts++;
                }
            }
        }
    }

    private async Task InitializeTerminalAsync()
    {
        try
        {
            Console.WriteLine($"Initializing terminal with ID: {_terminalId}");
            _dotNetRef = DotNetObjectReference.Create(this);
            
            // Initialize terminal with JavaScript interop
            var initialized = await JSRuntime.InvokeAsync<bool>("xtermTerminal.create", _terminalId, _dotNetRef);
            Console.WriteLine($"Terminal initialization result: {initialized}");
            
            if (initialized)
            {
                _isInitialized = true;
                Console.WriteLine("Terminal successfully initialized");
                
                // Subscribe to CLI output
                _outputSubscription = CliExecutor.Output
                    .Subscribe(async output => 
                    {
                        if (!_isDisposed && _isInitialized)
                        {
                            await InvokeAsync(async () =>
                            {
                                try
                                {
                                    await JSRuntime.InvokeVoidAsync("xtermTerminal.write", _terminalId, output.Text);
                                    
                                    // Check if process has ended and show prompt if needed
                                    await CheckProcessStateAndShowPrompt();
                                }
                                catch (Exception ex)
                                {
                                    Console.WriteLine($"Error writing to terminal: {ex.Message}");
                                }
                            });
                        }
                    });

                // Focus terminal and show welcome message
                await Task.Delay(100); // Small delay to ensure terminal is ready
                await JSRuntime.InvokeVoidAsync("xtermTerminal.focus", _terminalId);
                await JSRuntime.InvokeVoidAsync("xtermTerminal.write", _terminalId, 
                    "Welcome to CodeUI Terminal\r\nType commands and press Enter to execute.\r\n\r\n$ ");
                
                StateHasChanged();
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error initializing terminal: {ex.Message}");
        }
    }

    [JSInvokable]
    public async Task OnTerminalCommand(string command)
    {
        Console.WriteLine($"OnTerminalCommand called with: {command}");
        
        if (_isDisposed || !_isInitialized)
        {
            Console.WriteLine($"Terminal not ready: disposed={_isDisposed}, initialized={_isInitialized}");
            return;
        }

        try
        {
            await ProcessCommand(command);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error processing command: {ex.Message}");
            await JSRuntime.InvokeVoidAsync("xtermTerminal.write", _terminalId, 
                $"Error: {ex.Message}\r\n$ ");
        }
    }
    
    [JSInvokable]
    public async Task OnTerminalInput(string input)
    {
        Console.WriteLine($"OnTerminalInput called with: {input}");
        
        if (_isDisposed || !_isInitialized)
        {
            Console.WriteLine($"Terminal not ready: disposed={_isDisposed}, initialized={_isInitialized}");
            return;
        }

        try
        {
            // Check if we have a running process - if so, send input directly to it
            if (CliExecutor.CurrentProcess?.State == ProcessState.Running)
            {
                // Interactive mode: send input directly to the running process
                await HandleInteractiveInput(input);
            }
            else
            {
                // Command mode: buffer input until Enter, then execute command
                await HandleCommandInput(input);
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error handling terminal input: {ex.Message}");
        }
    }

    private async Task HandleInteractiveInput(string input)
    {
        // Handle special keys in interactive mode
        if (input == "\u0003") // Ctrl+C
        {
            try
            {
                await CliExecutor.SendSignalAsync(ProcessSignal.Interrupt);
                await JSRuntime.InvokeVoidAsync("xtermTerminal.write", _terminalId, "^C\r\n$ ");
            }
            catch (InvalidOperationException)
            {
                await CliExecutor.StopProcessAsync(graceful: false);
                await JSRuntime.InvokeVoidAsync("xtermTerminal.write", _terminalId, "^C\r\n$ ");
            }
            _currentInput = string.Empty;
            return;
        }

        // Normalize Enter and Backspace handling for better UX when no PTY
        if (input == "\r") // Enter
        {
            try
            {
                await CliExecutor.SendInputAsync("\r");
                await JSRuntime.InvokeVoidAsync("xtermTerminal.write", _terminalId, "\r\n");
            }
            catch (Exception ex)
            {
                await JSRuntime.InvokeVoidAsync("xtermTerminal.write", _terminalId, $"\r\nError sending input: {ex.Message}\r\n$ ");
            }
            return;
        }

        if (input == "\u007f") // Backspace
        {
            try
            {
                await CliExecutor.SendInputAsync(input);
                await JSRuntime.InvokeVoidAsync("xtermTerminal.write", _terminalId, "\b \b");
            }
            catch (Exception ex)
            {
                await JSRuntime.InvokeVoidAsync("xtermTerminal.write", _terminalId, $"\r\nError sending input: {ex.Message}\r\n$ ");
            }
            return;
        }

        try
        {
            // Send input directly to the running process
            await CliExecutor.SendInputAsync(input);
            // Echo the input to the terminal (the process output will also be displayed)
            await JSRuntime.InvokeVoidAsync("xtermTerminal.write", _terminalId, input);
        }
        catch (Exception ex)
        {
            await JSRuntime.InvokeVoidAsync("xtermTerminal.write", _terminalId, $"\r\nError sending input: {ex.Message}\r\n$ ");
        }
    }

    private async Task HandleCommandInput(string input)
    {
        // Handle special keys in command mode
        if (input == "\r") // Enter key
        {
            await JSRuntime.InvokeVoidAsync("xtermTerminal.write", _terminalId, "\r\n");
            
            // Process the command
            await ProcessCommand(_currentInput.Trim());
            _currentInput = string.Empty;
        }
        else if (input == "\u007f") // Backspace
        {
            if (_currentInput.Length > 0)
            {
                _currentInput = _currentInput.Substring(0, _currentInput.Length - 1);
                await JSRuntime.InvokeVoidAsync("xtermTerminal.write", _terminalId, "\b \b");
            }
        }
        else if (input == "\u0003") // Ctrl+C
        {
            // In command mode, Ctrl+C just cancels current input
            await JSRuntime.InvokeVoidAsync("xtermTerminal.write", _terminalId, "^C\r\n$ ");
            _currentInput = string.Empty;
        }
        else
        {
            // Add character to current input and echo
            _currentInput += input;
            await JSRuntime.InvokeVoidAsync("xtermTerminal.write", _terminalId, input);
        }
    }

    private async Task ProcessCommand(string command)
    {
        if (string.IsNullOrWhiteSpace(command))
        {
            await JSRuntime.InvokeVoidAsync("xtermTerminal.write", _terminalId, "$ ");
            return;
        }

        try
        {
            // Parse command and arguments
            var parts = command.Split(' ', StringSplitOptions.RemoveEmptyEntries);
            if (parts.Length == 0)
            {
                await JSRuntime.InvokeVoidAsync("xtermTerminal.write", _terminalId, "$ ");
                return;
            }

            var cmd = parts[0];
            var args = parts.Length > 1 ? string.Join(" ", parts.Skip(1)) : string.Empty;

            // Handle special terminal commands
            if (cmd == "clear")
            {
                await JSRuntime.InvokeVoidAsync("xtermTerminal.clear", _terminalId);
                await JSRuntime.InvokeVoidAsync("xtermTerminal.write", _terminalId, "$ ");
                return;
            }

            if (cmd == "help")
            {
                await JSRuntime.InvokeVoidAsync("xtermTerminal.write", _terminalId, 
                    "Available commands:\r\n" +
                    "  help        - Show this help message\r\n" +
                    "  clear       - Clear the terminal\r\n" +
                    "  echo        - Echo back text\r\n" +
                    "  pwd         - Show current directory (if available)\r\n" +
                    "  ls          - List directory contents (if available)\r\n" +
                    "  claude-code - Start interactive Claude Code CLI\r\n" +
                    "  bash        - Start interactive bash shell\r\n" +
                    "  Other commands will be executed via CLI executor\r\n$ ");
                return;
            }

            // Determine if this is an interactive command
            if (IsInteractiveCommand(cmd))
            {
                // Check if this command benefits from PTY support
                if (IsPtyPreferredCommand(cmd))
                {
                    // Get current terminal size from JavaScript
                    var terminalSize = await GetTerminalSizeAsync();
                    
                    // Start PTY process with terminal size
                    await CliExecutor.StartPtyProcessAsync(cmd, args, terminalSize: terminalSize);
                }
                else
                {
                    // Start interactive process using the regular method
                    await CliExecutor.StartInteractiveProcessAsync(cmd, args);
                }
                // No prompt here - process is running
            }
            else
            {
                // Execute non-interactive command and wait for completion
                await CliExecutor.ExecuteAsync(cmd, args);
                
                // Add prompt after command completion
                await JSRuntime.InvokeVoidAsync("xtermTerminal.write", _terminalId, "\r\n$ ");
            }
        }
        catch (Exception ex)
        {
            await JSRuntime.InvokeVoidAsync("xtermTerminal.write", _terminalId, 
                $"Error: {ex.Message}\r\n$ ");
        }
    }

    private static bool IsInteractiveCommand(string command)
    {
        // List of commands that are typically interactive
        var interactiveCommands = new[]
        {
            "claude-code", "gemini", "codex", // AI CLI tools
            "bash", "sh", "zsh", "fish", "cmd", "powershell", // Shells
            "python", "node", "irb", "psql", "mysql", // REPLs
            "vim", "nano", "emacs", // Editors
            "top", "htop", "less", "more", // Interactive viewers
            "ssh", "telnet", // Network tools
        };

        return interactiveCommands.Contains(command.ToLowerInvariant());
    }

    private static bool IsPtyPreferredCommand(string command)
    {
        // Commands that particularly benefit from PTY support (full terminal emulation)
        var ptyPreferredCommands = new[]
        {
            "bash", "sh", "zsh", "fish", "cmd", "powershell", // Shells
            "vim", "nano", "emacs", // Full-screen editors
            "top", "htop", "less", "more", // Interactive viewers with complex output
            "ssh", "telnet", // Network tools that need proper terminal handling
            "python", "node", "irb", // REPLs that benefit from proper signal handling
            "mysql", "psql", // Database shells
        };

        return ptyPreferredCommands.Contains(command.ToLowerInvariant());
    }

    private async Task<(int Columns, int Rows)?> GetTerminalSizeAsync()
    {
        try
        {
            var sizeResult = await JSRuntime.InvokeAsync<object>("xtermTerminal.getSize", _terminalId);
            if (sizeResult is JsonElement jsonElement && jsonElement.ValueKind == JsonValueKind.Object)
            {
                var cols = jsonElement.GetProperty("cols").GetInt32();
                var rows = jsonElement.GetProperty("rows").GetInt32();
                return (cols, rows);
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error getting terminal size: {ex.Message}");
        }
        
        // Return default size if unable to get current size
        return (80, 24);
    }

    private async Task CheckProcessStateAndShowPrompt()
    {
        var currentProcess = CliExecutor.CurrentProcess;
        
        // If no process is running or process has completed/failed, show prompt
        if (currentProcess == null || 
            currentProcess.State == ProcessState.Completed || 
            currentProcess.State == ProcessState.Failed)
        {
            // Only show prompt if we're not already showing it
            // (we can track this with a flag if needed)
            await JSRuntime.InvokeVoidAsync("xtermTerminal.write", _terminalId, "\r\n$ ");
        }
    }

    [JSInvokable]
    public async Task OnTerminalResize(int cols, int rows)
    {
        if (_isDisposed)
            return;

        try
        {
            // Handle terminal resize for PTY processes
            if (CliExecutor.CurrentProcess?.State == ProcessState.Running)
            {
                await CliExecutor.ResizeTerminalAsync(cols, rows);
            }
            
            Console.WriteLine($"Terminal resized to {cols}x{rows}");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error handling terminal resize: {ex.Message}");
        }
    }

    private async Task ClearTerminal()
    {
        if (_isDisposed || !_isInitialized)
            return;

        try
        {
            await JSRuntime.InvokeVoidAsync("xtermTerminal.clear", _terminalId);
            await JSRuntime.InvokeVoidAsync("xtermTerminal.write", _terminalId, "$ ");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error clearing terminal: {ex.Message}");
        }
    }

    private async Task FocusTerminal()
    {
        if (_isDisposed || !_isInitialized)
            return;

        try
        {
            await JSRuntime.InvokeVoidAsync("xtermTerminal.focus", _terminalId);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error focusing terminal: {ex.Message}");
        }
    }

    public async ValueTask DisposeAsync()
    {
        if (_isDisposed)
            return;

        _isDisposed = true;

        try
        {
            _outputSubscription?.Dispose();

            if (_isInitialized)
            {
                await JSRuntime.InvokeVoidAsync("xtermTerminal.dispose", _terminalId);
            }

            _dotNetRef?.Dispose();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error disposing terminal: {ex.Message}");
        }
    }
}
